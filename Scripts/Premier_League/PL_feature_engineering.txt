# Premier League feature engineering

# feature_engineering.py

import pandas as pd
from pathlib import Path
from datetime import datetime

# --- CONFIG ---
LEAGUE = 'Premier League'
SEASON = 2025
# Input data paths
PLAYER_PATH = Path("/Users/sanduandrei/Desktop/Betting_RAG/Output/Prem_output/player_fixture_stats_2025.json")
FIXTURE_PATH = Path("/Users/sanduandrei/Desktop/Betting_RAG/Output/Prem_teams/team_fixture_stats_2025.json")

# Output directory
OUTPUT_PATH = Path("/Users/sanduandrei/Desktop/Betting_RAG/Output/Prem_feature_engineering")
OUTPUT_PATH.mkdir(parents=True, exist_ok=True)

# ===============================================================
# 1Ô∏è‚É£ DATA LOADING
# ===============================================================
def load_player_data():
    df = pd.read_json(PLAYER_PATH)
    print(f"üìÇ Loaded {len(df)} player-fixture rows from {PLAYER_PATH.name}")
    return df


def load_fixture_stats():
    fx = pd.read_json(FIXTURE_PATH)
    fx.columns = fx.columns.str.strip().str.lower().str.replace(" ", "_")

    # --- Flexible column renaming with multiple possible aliases ---
    rename_map = {
        "corner_kicks": "corners",
        "ball_possession": "possession",
        "total_shots": "shots_total",
        "shots_on_goal": "shots_on",
        "shots_on_target": "shots_on",
        "shots_on_goals": "shots_on",
        "total_passes": "passes_total",
        "passes_accurate": "accurate_passes",
        "passes_%": "pass_accuracy_rate",
    }

    for old, new in rename_map.items():
        if old in fx.columns and new not in fx.columns:
            fx.rename(columns={old: new}, inplace=True)

    # --- Ensure essential numeric columns exist ---
    for col in ["shots_on", "shots_total", "corners", "possession"]:
        if col not in fx.columns:
            print(f"‚ö†Ô∏è Column '{col}' missing in fixture data ‚Äî defaulting to 0")
            fx[col] = 0

    print("üìã Fixture columns after load/rename:", list(fx.columns))
    print(f"üìÇ Loaded {len(fx)} fixture-level rows from {FIXTURE_PATH.name}")
    return fx


# ===============================================================
# 2Ô∏è‚É£ PLAYER-LEVEL FEATURE ENGINEERING
# ===============================================================
def engineer_player_efficiency(df):
    """(1.1) Compute finishing, conversion, duel, and defensive efficiency metrics."""
    for col in ["shots_on", "shots_total", "duels_total", "tackles"]:
        df[col] = df[col].replace(0, pd.NA)

    df["shots_on_target_ratio"] = df["shots_on"] / df["shots_total"]
    df["goal_conversion_rate"] = df["goals"] / df["shots_on"]
    df["duel_win_ratio"] = df["duels_won"] / df["duels_total"]
    df["tackle_success_rate"] = df["tackles"] / df["duels_total"]
    df["goal_involvement"] = df["goals"].fillna(0) + df["assists"].fillna(0)

    df.replace([float("inf"), -float("inf")], pd.NA, inplace=True)
    df.fillna(0, inplace=True)
    print("‚úÖ Engineered player-level efficiency features (1.1)")
    return df


def engineer_player_aggression(df):
    """(1.2) Compute disciplinary and aggression indicators."""
    df["minutes"].replace(0, pd.NA, inplace=True)
    df["duels_total"].replace(0, pd.NA, inplace=True)
    df["fouls_committed"].replace(0, pd.NA, inplace=True)

    df["cards_total"] = df["yellow_cards"].fillna(0) + df["red_cards"].fillna(0)
    df["cards_per_90"] = (df["cards_total"] / df["minutes"]) * 90
    df["fouls_per_90"] = (df["fouls_committed"] / df["minutes"]) * 90
    df["cards_per_foul"] = df["cards_total"] / df["fouls_committed"]
    df["duel_foul_ratio"] = df["fouls_committed"] / df["duels_total"]

    df.replace([float("inf"), -float("inf")], pd.NA, inplace=True)
    df.fillna(0, inplace=True)
    print("‚úÖ Engineered player aggression & disciplinary features (1.2)")
    return df


def engineer_player_form(df):
    """(1.3) Compute player form and consistency metrics based on last 4 fixtures."""
    df = df.sort_values(by=["player_id", "fixture"]).copy()
    df["rating"] = pd.to_numeric(df["rating"], errors="coerce")

    group = df.groupby("player_id")
    df["avg_rating_last_4"] = group["rating"].transform(lambda x: x.rolling(window=4, min_periods=1).mean())
    df["avg_goals_last_4"] = group["goals"].transform(lambda x: x.rolling(window=4, min_periods=1).mean())
    df["avg_assists_last_4"] = group["assists"].transform(lambda x: x.rolling(window=4, min_periods=1).mean())

    df["goal_involvement_last_4"] = df["avg_goals_last_4"] + df["avg_assists_last_4"]
    df["form_index"] = (df["avg_rating_last_4"].fillna(0) * 0.6) + (df["goal_involvement_last_4"].fillna(0) * 0.4)
    df["performance_variance"] = group["rating"].transform(lambda x: x.rolling(window=4, min_periods=2).var())

    df.fillna(0, inplace=True)
    print("‚úÖ Engineered player form & consistency features (1.3)")
    return df


# ===============================================================
# 3Ô∏è‚É£ TEAM-LEVEL FEATURE ENGINEERING
# ===============================================================
def engineer_team_core_features(df):
    """(2.1) Aggregate player-level data into team-level per fixture."""
    agg_map = {
        "goals": "sum",
        "assists": "sum",
        "shots_total": "sum",
        "shots_on": "sum",
        "passes_total": "sum",
        "accurate_passes": "sum",
        "fouls_committed": "sum",
        "fouls_drawn": "sum",
        "yellow_cards": "sum",
        "red_cards": "sum",
        "minutes": "sum",
        "tackles": "sum",
        "interceptions": "sum",
    }

    team_fixture = df.groupby(["fixture", "team"], dropna=False).agg(agg_map).reset_index()

    team_fixture["shots_accuracy_for"] = team_fixture["shots_on"] / team_fixture["shots_total"].replace(0, pd.NA)
    team_fixture["pass_accuracy_team"] = team_fixture["accurate_passes"] / team_fixture["passes_total"].replace(0, pd.NA)

    team_fixture.fillna(0, inplace=True)
    print(f"‚úÖ Engineered team-level core aggregates (2.1): {len(team_fixture)} rows")
    return team_fixture


def merge_team_with_fixture(team_df, fixture_df):
    if fixture_df is None or fixture_df.empty:
        print("‚ö†Ô∏è Fixture stats are empty or not loaded ‚Äî skipping merge.")
        team_df["shots_on"] = 0
        team_df["shots_total"] = 0
        team_df["corners"] = 0
        team_df["possession"] = 0
        team_df["dominance_index"] = 0
        return team_df

    fx = fixture_df.copy()
    df = team_df.copy()

    # Normalize columns
    fx.columns = fx.columns.str.strip().str.lower().str.replace(" ", "_")

    # Ensure expected columns exist
    for col in ["shots_on", "shots_total", "corners", "possession"]:
        if col not in fx.columns:
            print(f"‚ö†Ô∏è '{col}' not in fixture file ‚Äî creating empty column.")
            fx[col] = 0

    # Create a robust join key
    fx["fixture_key"] = fx["home_team"].str.lower().str.strip() + "_vs_" + fx["away_team"].str.lower().str.strip()
    df["fixture_key"] = df["fixture"].str.lower().str.strip()

    # Merge safely
    merged = df.merge(
        fx[
            [
                "fixture_key", "team", "home_team", "away_team",
                "home_goals", "away_goals", "final_score",
                "expected_goals", "goals_prevented",
                "possession", "corners", "shots_total", "shots_on",
            ]
        ],
        on=["fixture_key", "team"],
        how="left",
    )

    # Fill missing values
    for col in ["shots_on", "shots_total", "corners", "possession"]:
        if col not in merged.columns:
            print(f"‚ö†Ô∏è Column '{col}' missing after merge ‚Äî adding zeros.")
            merged[col] = 0
        merged[col] = merged[col].fillna(0)

    merged["dominance_index"] = (
        (merged["possession"] * 0.4)
        + ((merged["shots_on"] / merged["shots_total"].replace(0, pd.NA)).fillna(0) * 0.3)
        + ((merged["corners"] / (merged["corners"].max() or 1)) * 0.3)
    )

    print("‚úÖ Successfully merged fixture-level stats.")
    return merged




def engineer_team_strength_efficiency(team_df):
    """(2.2) Compute advanced team efficiency metrics."""
    df = team_df.copy()
    for col in ["shots_total", "passes_total", "tackles", "fouls_committed"]:
        df[col] = df[col].replace(0, pd.NA)

    df["goal_conversion_rate"] = df["goals"] / df["shots_total"]
    df["shot_on_target_ratio"] = df["shots_on"] / df["shots_total"]
    df["goals_per_90"] = (df["goals"] / df["minutes"]) * 90

    df["defensive_duel_efficiency"] = df["tackles"] / (df["tackles"] + df["interceptions"])
    df["cards_total"] = df["yellow_cards"] + df["red_cards"]
    df["cards_per_foul_team"] = df["cards_total"] / df["fouls_committed"]

    df["control_index"] = (
        (df["pass_accuracy_team"].fillna(0) * 0.5)
        + ((df["passes_total"].fillna(0) / df["passes_total"].max()) * 0.3)
        + ((df["corners"].fillna(0) / (df["corners"].max() or 1)) * 0.2)
    )

    df.replace([float("inf"), -float("inf")], pd.NA, inplace=True)
    df.fillna(0, inplace=True)
    print(f"‚úÖ Engineered team strength & efficiency metrics (2.2): {len(df)} rows")
    return df


def engineer_team_aggression_discipline(team_df):
    """(2.3) Compute team-level aggression & discipline."""
    df = team_df.copy()
    for col in ["minutes", "fouls_committed", "yellow_cards", "red_cards"]:
        df[col] = df[col].replace(0, pd.NA)

    df["cards_total"] = df["yellow_cards"] + df["red_cards"]
    df["fouls_per_90_team"] = (df["fouls_committed"] / df["minutes"]) * 90
    df["cards_per_90_team"] = (df["cards_total"] / df["minutes"]) * 90
    df["fouls_per_duel_team"] = df["fouls_committed"] / (df["tackles"] + df["interceptions"])

    df["aggression_index_raw"] = (
        (df["fouls_per_90_team"] * 0.5)
        + (df["cards_per_90_team"] * 0.3)
        + (df["fouls_per_duel_team"] * 0.2)
    )

    min_val, max_val = df["aggression_index_raw"].min(), df["aggression_index_raw"].max()
    df["aggression_index_norm"] = (df["aggression_index_raw"] - min_val) / (max_val - min_val)

    df.fillna(0, inplace=True)
    print(f"‚úÖ Engineered team aggression & discipline metrics (2.3): {len(df)} rows")
    return df


def engineer_team_form_consistency(team_df):
    """(2.4) Compute rolling team form, momentum, and consistency."""
    df = team_df.copy().sort_values(by=["team", "fixture"]).reset_index(drop=True)
    group = df.groupby("team")
    w = 5

    df["avg_goals_last_5"] = group["goals"].transform(lambda x: x.rolling(w, 1).mean())
    df["avg_cards_last_5"] = group["cards_total"].transform(lambda x: x.rolling(w, 1).mean())
    df["form_index_team"] = (
        (df["avg_goals_last_5"] * 0.5)
        - (df["avg_cards_last_5"] * 0.3)
        + (df["goal_conversion_rate"] * 0.2)
    )

    df.fillna(0, inplace=True)
    print(f"‚úÖ Engineered team form & consistency metrics (2.4): {len(df)} rows")
    return df


# ===============================================================
# 4Ô∏è‚É£ PLAYER CONTEXTUAL (OPPONENT-BASED)
# ===============================================================
def engineer_player_contextual_features(player_df, team_df):
    """(1.4) Merge opponent-based contextual features for each player record."""
    df = player_df.copy()
    team = team_df.copy()

    # --- Opponent mapping ---
    fixture_teams = team.groupby("fixture")["team"].apply(list).reset_index(name="teams")
    fixture_teams = fixture_teams[fixture_teams["teams"].apply(len) == 2]

    opponent_map = {}
    for _, row in fixture_teams.iterrows():
        t1, t2 = row["teams"]
        opponent_map[(row["fixture"], t1)] = t2
        opponent_map[(row["fixture"], t2)] = t1

    # --- Merge team stats for player team ---
    df = df.merge(
        team[["fixture", "team", "aggression_index_norm", "form_index_team", "control_index"]],
        on=["fixture", "team"],
        how="left",
    )

    # --- Merge opponent stats ---
    df["opponent"] = df.apply(lambda x: opponent_map.get((x["fixture"], x["team"])), axis=1)
    df = df.merge(
        team[
            ["fixture", "team", "aggression_index_norm", "cards_per_90_team", "fouls_per_90_team", "form_index_team", "control_index"]
        ],
        left_on=["fixture", "opponent"],
        right_on=["fixture", "team"],
        how="left",
        suffixes=("", "_opp"),
    )

    if "team_opp" in df.columns:
        df.drop(columns=["team_opp"], inplace=True)

    # --- Derived differentials ---
    df["agg_diff"] = df["aggression_index_norm"] - df["aggression_index_norm_opp"]
    df["form_diff"] = df["form_index_team"] - df["form_index_team_opp"]
    df["control_diff"] = df["control_index"] - df["control_index_opp"]

    # --- Player risk model ---
    df["is_defensive"] = df["position"].fillna("").str.contains("DF|CB|LB|RB", case=False).astype(int)
    df["expected_foul_pressure"] = df["aggression_index_norm_opp"] * df["is_defensive"]
    df["expected_card_risk"] = (
        df["cards_per_90_team_opp"].fillna(0)
        * df["aggression_index_norm_opp"].fillna(0)
        * df["is_defensive"]
    )

    df.fillna(0, inplace=True)
    print(f"‚úÖ Engineered contextual opponent-based player features (1.4): {len(df)} rows")
    return df


# ===============================================================
# 5Ô∏è‚É£ MASTER PIPELINE
# ===============================================================
def run_feature_engineering():
    # --- Load base player data ---
    df = load_player_data()

    # --- Load fixture-level stats before any merging ---
    fixture_stats = load_fixture_stats()  # ‚úÖ Ensure this is called early

    # ===============================================================
    # üßç PLAYER-LEVEL FEATURES
    # ===============================================================
    df = engineer_player_efficiency(df)
    df = engineer_player_aggression(df)
    df = engineer_player_form(df)

    # ===============================================================
    # üèüÔ∏è TEAM-LEVEL FEATURES
    # ===============================================================
    team_features = engineer_team_core_features(df)

    # ‚úÖ NEW ‚Äî Merge with fixture-level data now that it's loaded
    team_features = merge_team_with_fixture(team_features, fixture_stats)

    # Continue as before
    team_features = engineer_team_strength_efficiency(team_features)
    team_features = engineer_team_aggression_discipline(team_features)
    team_features = engineer_team_form_consistency(team_features)

    # --- Contextual features ---
    df = engineer_player_contextual_features(df, team_features)

    # --- Save outputs ---
    player_csv = OUTPUT_PATH / f"player_engineered_features_{SEASON}.csv"
    player_json = OUTPUT_PATH / f"player_engineered_features_{SEASON}.json"
    df.to_csv(player_csv, index=False)
    df.to_json(player_json, orient="records", indent=4)

    team_csv = OUTPUT_PATH / f"team_engineered_features_{SEASON}.csv"
    team_json = OUTPUT_PATH / f"team_engineered_features_{SEASON}.json"
    team_features.to_csv(team_csv, index=False)
    team_features.to_json(team_json, orient="records", indent=4)

    print(f"üíæ Saved player + team engineered datasets to {OUTPUT_PATH}")
    print(f"   ‚Ä¢ Player rows: {len(df)}")
    print(f"   ‚Ä¢ Team rows: {len(team_features)}")
    return df, team_features


# ===============================================================
# MAIN EXECUTION
# ===============================================================
if __name__ == "__main__":
    start = datetime.now()
    run_feature_engineering()
    print(f"‚è±Ô∏è Completed in {(datetime.now() - start).total_seconds():.2f} seconds")